/* Copyright 2020 UPMEM. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/*
 * Default linker script for DPU programs.
 * The bootstrap sequence is generated by the studio as __bootstrap.
 * The two DPU memories (IRAM and WRAM) are mapped on two different
 * "virtual" spaces:
 *  - IRAM: starts at address 0x80000000, which may imply fixups
 *    when loading and debugging of programs
 *  - WRAM: exposed as is at address 0x00000000
 *
 * In addition, the run-time environment information is stored into
 * a virtual physical space at 0x40000000.
 */
ENTRY(__bootstrap)
MEMORY {
    iram (rx) : ORIGIN = 0x80000000, LENGTH = 32K
    mram (wa) : ORIGIN = 0x08000000, LENGTH = 64M
    wram (wa) : ORIGIN = 0x00000000, LENGTH = 64K
    atomic (r) : ORIGIN = 0xF0000000, LENGTH = 256
}
SECTIONS
{
  /*
   * Merge every text section into .text.
   */
  .text : {
    *(.text.__bootstrap)
    *(.text)
    *(.text.*) 
  } > iram

  /*
   * Atomic bits 'allocator'
   */
  .atomic (NOLOAD) : {
    __atomic_start_addr = .;
    . = . + 200;
    __atomic_used_addr = .;
    *(.atomic)
    __atomic_end_addr = .;
  } > atomic

  /*
   * Locate every other section as data.
   */
  .data : {
    KEEP(*(.data.__sys_zero))
    . += MAX(8, .);
    /* WRAM accessible using loads and stores with immediate 11-bit offsets */
    *(.data.immediate_memory .data.immediate_memory.*)
    HIDDEN(__imm_mem_end = .);
    ASSERT(__imm_mem_end < 2048, "immediate memory not accessible with 11-bit address")
    __rodata_start_addr = .;
    *(.rodata .rodata.*)
    __rodata_end_addr = .;
    *(.bss .bss.*)
    *(COMMON)
    /* Data that we want to keep even there seems to be no use,
     * usually because host may need it.
     */
    KEEP(*(.data.__sys_keep))
    *(.data .data.*)
    . = ALIGN(8);
  } > wram

  .data.__sys_host : {
    . = ALIGN(8);
    KEEP(*(.dpu_host))
  } > wram

  .data.__sys_profiling : {
    . = ALIGN(4);
    KEEP(*(.dpu_profiling))
  } > wram

  .data.stacks (NOLOAD) : {
    ASSERT(NR_TASKLETS >= 0 && NR_TASKLETS <= 24, "NR_TASKLETS should be in the range: [0; 24]")
    ASSERT(((STACK_SIZE_TASKLET_0  % 8 == 0) && (STACK_SIZE_TASKLET_0  > 0)) || (NR_TASKLETS <= 0 ), "STACK_SIZE_TASKLET_0  should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_1  % 8 == 0) && (STACK_SIZE_TASKLET_1  > 0)) || (NR_TASKLETS <= 1 ), "STACK_SIZE_TASKLET_1  should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_2  % 8 == 0) && (STACK_SIZE_TASKLET_2  > 0)) || (NR_TASKLETS <= 2 ), "STACK_SIZE_TASKLET_2  should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_3  % 8 == 0) && (STACK_SIZE_TASKLET_3  > 0)) || (NR_TASKLETS <= 3 ), "STACK_SIZE_TASKLET_3  should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_4  % 8 == 0) && (STACK_SIZE_TASKLET_4  > 0)) || (NR_TASKLETS <= 4 ), "STACK_SIZE_TASKLET_4  should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_5  % 8 == 0) && (STACK_SIZE_TASKLET_5  > 0)) || (NR_TASKLETS <= 5 ), "STACK_SIZE_TASKLET_5  should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_6  % 8 == 0) && (STACK_SIZE_TASKLET_6  > 0)) || (NR_TASKLETS <= 6 ), "STACK_SIZE_TASKLET_6  should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_7  % 8 == 0) && (STACK_SIZE_TASKLET_7  > 0)) || (NR_TASKLETS <= 7 ), "STACK_SIZE_TASKLET_7  should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_8  % 8 == 0) && (STACK_SIZE_TASKLET_8  > 0)) || (NR_TASKLETS <= 8 ), "STACK_SIZE_TASKLET_8  should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_9  % 8 == 0) && (STACK_SIZE_TASKLET_9  > 0)) || (NR_TASKLETS <= 9 ), "STACK_SIZE_TASKLET_9  should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_10 % 8 == 0) && (STACK_SIZE_TASKLET_10 > 0)) || (NR_TASKLETS <= 10), "STACK_SIZE_TASKLET_10 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_11 % 8 == 0) && (STACK_SIZE_TASKLET_11 > 0)) || (NR_TASKLETS <= 11), "STACK_SIZE_TASKLET_11 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_12 % 8 == 0) && (STACK_SIZE_TASKLET_12 > 0)) || (NR_TASKLETS <= 12), "STACK_SIZE_TASKLET_12 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_13 % 8 == 0) && (STACK_SIZE_TASKLET_13 > 0)) || (NR_TASKLETS <= 13), "STACK_SIZE_TASKLET_13 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_14 % 8 == 0) && (STACK_SIZE_TASKLET_14 > 0)) || (NR_TASKLETS <= 14), "STACK_SIZE_TASKLET_14 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_15 % 8 == 0) && (STACK_SIZE_TASKLET_15 > 0)) || (NR_TASKLETS <= 15), "STACK_SIZE_TASKLET_15 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_16 % 8 == 0) && (STACK_SIZE_TASKLET_16 > 0)) || (NR_TASKLETS <= 16), "STACK_SIZE_TASKLET_16 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_17 % 8 == 0) && (STACK_SIZE_TASKLET_17 > 0)) || (NR_TASKLETS <= 17), "STACK_SIZE_TASKLET_17 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_18 % 8 == 0) && (STACK_SIZE_TASKLET_18 > 0)) || (NR_TASKLETS <= 18), "STACK_SIZE_TASKLET_18 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_19 % 8 == 0) && (STACK_SIZE_TASKLET_19 > 0)) || (NR_TASKLETS <= 19), "STACK_SIZE_TASKLET_19 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_20 % 8 == 0) && (STACK_SIZE_TASKLET_20 > 0)) || (NR_TASKLETS <= 20), "STACK_SIZE_TASKLET_20 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_21 % 8 == 0) && (STACK_SIZE_TASKLET_21 > 0)) || (NR_TASKLETS <= 21), "STACK_SIZE_TASKLET_21 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_22 % 8 == 0) && (STACK_SIZE_TASKLET_22 > 0)) || (NR_TASKLETS <= 22), "STACK_SIZE_TASKLET_22 should be a multiple of 8 and > 0")
    ASSERT(((STACK_SIZE_TASKLET_23 % 8 == 0) && (STACK_SIZE_TASKLET_23 > 0)) || (NR_TASKLETS <= 23), "STACK_SIZE_TASKLET_23 should be a multiple of 8 and > 0")
    ASSERT((NR_TASKLETS > 0 ) || (STACK_SIZE_TASKLET_0  == 0) , "STACK_SIZE_TASKLET_0  should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 1 ) || (STACK_SIZE_TASKLET_1  == 0) , "STACK_SIZE_TASKLET_1  should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 2 ) || (STACK_SIZE_TASKLET_2  == 0) , "STACK_SIZE_TASKLET_2  should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 3 ) || (STACK_SIZE_TASKLET_3  == 0) , "STACK_SIZE_TASKLET_3  should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 4 ) || (STACK_SIZE_TASKLET_4  == 0) , "STACK_SIZE_TASKLET_4  should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 5 ) || (STACK_SIZE_TASKLET_5  == 0) , "STACK_SIZE_TASKLET_5  should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 6 ) || (STACK_SIZE_TASKLET_6  == 0) , "STACK_SIZE_TASKLET_6  should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 7 ) || (STACK_SIZE_TASKLET_7  == 0) , "STACK_SIZE_TASKLET_7  should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 8 ) || (STACK_SIZE_TASKLET_8  == 0) , "STACK_SIZE_TASKLET_8  should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 9 ) || (STACK_SIZE_TASKLET_9  == 0) , "STACK_SIZE_TASKLET_9  should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 10) || (STACK_SIZE_TASKLET_10 == 0) , "STACK_SIZE_TASKLET_10 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 11) || (STACK_SIZE_TASKLET_11 == 0) , "STACK_SIZE_TASKLET_11 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 12) || (STACK_SIZE_TASKLET_12 == 0) , "STACK_SIZE_TASKLET_12 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 13) || (STACK_SIZE_TASKLET_13 == 0) , "STACK_SIZE_TASKLET_13 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 14) || (STACK_SIZE_TASKLET_14 == 0) , "STACK_SIZE_TASKLET_14 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 15) || (STACK_SIZE_TASKLET_15 == 0) , "STACK_SIZE_TASKLET_15 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 16) || (STACK_SIZE_TASKLET_16 == 0) , "STACK_SIZE_TASKLET_16 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 17) || (STACK_SIZE_TASKLET_17 == 0) , "STACK_SIZE_TASKLET_17 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 18) || (STACK_SIZE_TASKLET_18 == 0) , "STACK_SIZE_TASKLET_18 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 19) || (STACK_SIZE_TASKLET_19 == 0) , "STACK_SIZE_TASKLET_19 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 20) || (STACK_SIZE_TASKLET_20 == 0) , "STACK_SIZE_TASKLET_20 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 21) || (STACK_SIZE_TASKLET_21 == 0) , "STACK_SIZE_TASKLET_21 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 22) || (STACK_SIZE_TASKLET_22 == 0) , "STACK_SIZE_TASKLET_22 should be equal to 0 as the tasklet is not active")
    ASSERT((NR_TASKLETS > 23) || (STACK_SIZE_TASKLET_23 == 0) , "STACK_SIZE_TASKLET_23 should be equal to 0 as the tasklet is not active")
    . = ALIGN(8);
    __sys_stack_thread_0  = .;
    . += STACK_SIZE_TASKLET_0;
    __sys_stack_thread_1  = .;
    . += STACK_SIZE_TASKLET_1;
    __sys_stack_thread_2  = .;
    . += STACK_SIZE_TASKLET_2;
    __sys_stack_thread_3  = .;
    . += STACK_SIZE_TASKLET_3;
    __sys_stack_thread_4  = .;
    . += STACK_SIZE_TASKLET_4;
    __sys_stack_thread_5  = .;
    . += STACK_SIZE_TASKLET_5;
    __sys_stack_thread_6  = .;
    . += STACK_SIZE_TASKLET_6;
    __sys_stack_thread_7  = .;
    . += STACK_SIZE_TASKLET_7;
    __sys_stack_thread_8  = .;
    . += STACK_SIZE_TASKLET_8;
    __sys_stack_thread_9  = .;
    . += STACK_SIZE_TASKLET_9;
    __sys_stack_thread_10 = .;
    . += STACK_SIZE_TASKLET_10;
    __sys_stack_thread_11 = .;
    . += STACK_SIZE_TASKLET_11;
    __sys_stack_thread_12 = .;
    . += STACK_SIZE_TASKLET_12;
    __sys_stack_thread_13 = .;
    . += STACK_SIZE_TASKLET_13;
    __sys_stack_thread_14 = .;
    . += STACK_SIZE_TASKLET_14;
    __sys_stack_thread_15 = .;
    . += STACK_SIZE_TASKLET_15;
    __sys_stack_thread_16 = .;
    . += STACK_SIZE_TASKLET_16;
    __sys_stack_thread_17 = .;
    . += STACK_SIZE_TASKLET_17;
    __sys_stack_thread_18 = .;
    . += STACK_SIZE_TASKLET_18;
    __sys_stack_thread_19 = .;
    . += STACK_SIZE_TASKLET_19;
    __sys_stack_thread_20 = .;
    . += STACK_SIZE_TASKLET_20;
    __sys_stack_thread_21 = .;
    . += STACK_SIZE_TASKLET_21;
    __sys_stack_thread_22 = .;
    . += STACK_SIZE_TASKLET_22;
    __sys_stack_thread_23 = .;
    . += STACK_SIZE_TASKLET_23;
    . = ALIGN(8);
  } > wram


  .data.sw_cache (NOLOAD): {
    . = ALIGN(8);
    __sw_cache_buffer = .;
    . += 8 * NR_TASKLETS;
  } > wram

  .data.heap_pointer_reset (NOLOAD) : {
    /* Start of heap: must be aligned on DMA size.
     * Stored as a symbol "__reset_heap_pointer", so that
     * the bootstrap just moves the value into a register to
     * initialize heap pointer at each reboot.
     */
    . = ALIGN(8);
    PROVIDE(__sys_heap_pointer_reset = .);
  } > wram

  .mram.noinit (NOLOAD) : {
    *(.mram.noinit .mram.noinit.*)
    KEEP(*(.mram.noinit.keep .mram.noinit.keep.*))
  } > mram

  .mram : {
    *(.mram .mram.*)
    KEEP(*(.mram.keep .mram.keep.*))
    . = ALIGN(8);
    __sys_used_mram_end = .;
  } > mram
}
